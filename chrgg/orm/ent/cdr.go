// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/twiglab/h2o/chrgg/orm/ent/cdr"
)

// CDR is the model entity for the CDR schema.
type CDR struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// 设备号
	DeviceCode string `json:"device_code,omitempty"`
	// 设备类型
	DeviceType string `json:"device_type,omitempty"`
	// 最后一次读数
	LastDataValue int64 `json:"last_data_value,omitempty"`
	// 当前读数
	DataValue int64 `json:"data_value,omitempty"`
	// 用户ID
	LastDataCode string `json:"last_data_code,omitempty"`
	// 用户ID
	DataCode string `json:"data_code,omitempty"`
	// 上一次时间
	LastDataTime time.Time `json:"last_data_time,omitempty"`
	// 当前时间
	DataTime time.Time `json:"data_time,omitempty"`
	// 计费方案ID
	PloyID string `json:"ploy_id,omitempty"`
	// 计费规则ID
	RuleID string `json:"rule_id,omitempty"`
	// 计费数值
	Value int64 `json:"value,omitempty"`
	// 计费单价
	UnitFee int64 `json:"unit_fee,omitempty"`
	// 当次费用
	Fee int64 `json:"fee,omitempty"`
	// 位置编号
	PosCode string `json:"pos_code,omitempty"`
	// 项目编号
	Project string `json:"project,omitempty"`
	// 备注
	Remark       string `json:"remark,omitempty"`
	selectValues sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*CDR) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case cdr.FieldLastDataValue, cdr.FieldDataValue, cdr.FieldValue, cdr.FieldUnitFee, cdr.FieldFee:
			values[i] = new(sql.NullInt64)
		case cdr.FieldID, cdr.FieldDeviceCode, cdr.FieldDeviceType, cdr.FieldLastDataCode, cdr.FieldDataCode, cdr.FieldPloyID, cdr.FieldRuleID, cdr.FieldPosCode, cdr.FieldProject, cdr.FieldRemark:
			values[i] = new(sql.NullString)
		case cdr.FieldLastDataTime, cdr.FieldDataTime:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the CDR fields.
func (_m *CDR) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case cdr.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				_m.ID = value.String
			}
		case cdr.FieldDeviceCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field device_code", values[i])
			} else if value.Valid {
				_m.DeviceCode = value.String
			}
		case cdr.FieldDeviceType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field device_type", values[i])
			} else if value.Valid {
				_m.DeviceType = value.String
			}
		case cdr.FieldLastDataValue:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field last_data_value", values[i])
			} else if value.Valid {
				_m.LastDataValue = value.Int64
			}
		case cdr.FieldDataValue:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field data_value", values[i])
			} else if value.Valid {
				_m.DataValue = value.Int64
			}
		case cdr.FieldLastDataCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field last_data_code", values[i])
			} else if value.Valid {
				_m.LastDataCode = value.String
			}
		case cdr.FieldDataCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field data_code", values[i])
			} else if value.Valid {
				_m.DataCode = value.String
			}
		case cdr.FieldLastDataTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_data_time", values[i])
			} else if value.Valid {
				_m.LastDataTime = value.Time
			}
		case cdr.FieldDataTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field data_time", values[i])
			} else if value.Valid {
				_m.DataTime = value.Time
			}
		case cdr.FieldPloyID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ploy_id", values[i])
			} else if value.Valid {
				_m.PloyID = value.String
			}
		case cdr.FieldRuleID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field rule_id", values[i])
			} else if value.Valid {
				_m.RuleID = value.String
			}
		case cdr.FieldValue:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field value", values[i])
			} else if value.Valid {
				_m.Value = value.Int64
			}
		case cdr.FieldUnitFee:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field unit_fee", values[i])
			} else if value.Valid {
				_m.UnitFee = value.Int64
			}
		case cdr.FieldFee:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field fee", values[i])
			} else if value.Valid {
				_m.Fee = value.Int64
			}
		case cdr.FieldPosCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pos_code", values[i])
			} else if value.Valid {
				_m.PosCode = value.String
			}
		case cdr.FieldProject:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field project", values[i])
			} else if value.Valid {
				_m.Project = value.String
			}
		case cdr.FieldRemark:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remark", values[i])
			} else if value.Valid {
				_m.Remark = value.String
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// GetValue returns the ent.Value that was dynamically selected and assigned to the CDR.
// This includes values selected through modifiers, order, etc.
func (_m *CDR) GetValue(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// Update returns a builder for updating this CDR.
// Note that you need to call CDR.Unwrap() before calling this method if this CDR
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *CDR) Update() *CDRUpdateOne {
	return NewCDRClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the CDR entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *CDR) Unwrap() *CDR {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: CDR is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *CDR) String() string {
	var builder strings.Builder
	builder.WriteString("CDR(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("device_code=")
	builder.WriteString(_m.DeviceCode)
	builder.WriteString(", ")
	builder.WriteString("device_type=")
	builder.WriteString(_m.DeviceType)
	builder.WriteString(", ")
	builder.WriteString("last_data_value=")
	builder.WriteString(fmt.Sprintf("%v", _m.LastDataValue))
	builder.WriteString(", ")
	builder.WriteString("data_value=")
	builder.WriteString(fmt.Sprintf("%v", _m.DataValue))
	builder.WriteString(", ")
	builder.WriteString("last_data_code=")
	builder.WriteString(_m.LastDataCode)
	builder.WriteString(", ")
	builder.WriteString("data_code=")
	builder.WriteString(_m.DataCode)
	builder.WriteString(", ")
	builder.WriteString("last_data_time=")
	builder.WriteString(_m.LastDataTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("data_time=")
	builder.WriteString(_m.DataTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("ploy_id=")
	builder.WriteString(_m.PloyID)
	builder.WriteString(", ")
	builder.WriteString("rule_id=")
	builder.WriteString(_m.RuleID)
	builder.WriteString(", ")
	builder.WriteString("value=")
	builder.WriteString(fmt.Sprintf("%v", _m.Value))
	builder.WriteString(", ")
	builder.WriteString("unit_fee=")
	builder.WriteString(fmt.Sprintf("%v", _m.UnitFee))
	builder.WriteString(", ")
	builder.WriteString("fee=")
	builder.WriteString(fmt.Sprintf("%v", _m.Fee))
	builder.WriteString(", ")
	builder.WriteString("pos_code=")
	builder.WriteString(_m.PosCode)
	builder.WriteString(", ")
	builder.WriteString("project=")
	builder.WriteString(_m.Project)
	builder.WriteString(", ")
	builder.WriteString("remark=")
	builder.WriteString(_m.Remark)
	builder.WriteByte(')')
	return builder.String()
}

// CDRs is a parsable slice of CDR.
type CDRs []*CDR
